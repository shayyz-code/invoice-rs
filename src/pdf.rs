use std::error::Error;
use std::fs;

use headless_chrome::Browser;
use headless_chrome::protocol::cdp::Page;

use crate::models::Invoice;

pub fn generate_invoice_pdf(invoice: &Invoice) -> Result<(), Box<dyn Error>> {
    let browser = Browser::default()?;

    let tab = browser.new_tab()?;

    // Navigate to wikipedia
    tab.navigate_to("https://www.wikipedia.org")?;

    // Wait for network/javascript/dom to make the search-box available
    // and click it.
    tab.wait_for_element("input#searchInput")?.click()?;

    // Type in a query and press `Enter`
    tab.type_str("WebKit")?.press_key("Enter")?;

    // We should end up on the WebKit-page once navigated
    let elem = tab.wait_for_element("#firstHeading")?;
    assert!(tab.get_url().ends_with("WebKit"));

    /// Take a screenshot of the entire browser window
    let jpeg_data =
        tab.capture_screenshot(Page::CaptureScreenshotFormatOption::Jpeg, None, None, true)?;
    // Save the screenshot to disc
    std::fs::write("screenshot.jpeg", jpeg_data)?;

    /// Take a screenshot of just the WebKit-Infobox
    let png_data = tab
        .wait_for_element("#mw-content-text > div > table.infobox.vevent")?
        .capture_screenshot(Page::CaptureScreenshotFormatOption::Png)?;
    // Save the screenshot to disc
    std::fs::write("screenshot.png", png_data)?;

    // Run JavaScript in the page
    let remote_object = elem.call_js_fn(
        r#"
        function getIdTwice () {
            // `this` is always the element that you called `call_js_fn` on
            const id = this.id;
            return id + id;
        }
    "#,
        vec![],
        false,
    )?;
    match remote_object.value {
        Some(returned_string) => {
            dbg!(&returned_string);
            assert_eq!(returned_string, "firstHeadingfirstHeading".to_string());
        }
        _ => unreachable!(),
    };

    Ok(())
}

pub fn generate_invoice_html(invoice: &Invoice) -> Result<String, Box<dyn std::error::Error>> {
    let html = format!(
        r#"
        <html>
        <head>
            <meta charset="utf-8" />
            <style>
                body {{
                    font-family: 'Inter', sans-serif;
                    background-color: #f9f9fb;
                    color: #333;
                    padding: 40px;
                }}
                .invoice {{
                    max-width: 600px;
                    margin: auto;
                    background: white;
                    border-radius: 12px;
                    box-shadow: 0 4px 16px rgba(0,0,0,0.1);
                    padding: 40px;
                }}
                h1 {{
                    color: #a855f7;
                    text-align: center;
                }}
                p {{ line-height: 1.6; }}
                .footer {{
                    text-align: center;
                    color: #777;
                    margin-top: 40px;
                    font-size: 0.9em;
                }}
            </style>
        </head>
        <body>
            <div class="invoice">
                <h1>RustRaccoon Invoice</h1>
                <p><strong>Invoice ID:</strong> {}</p>
                <p><strong>Customer:</strong> {}</p>
                <p><strong>Amount:</strong> ${:.2}</p>
                <p><strong>Date:</strong> {}</p>
                <div class="footer">Generated by RustRaccoon ü¶ù</div>
            </div>
        </body>
        </html>
    "#,
        invoice.number, invoice.client, invoice.total, invoice.status
    );

    let html_path = format!("invoice_{}.html", invoice.number);

    fs::write(&html_path, &html)?;

    Ok(html_path)
}
